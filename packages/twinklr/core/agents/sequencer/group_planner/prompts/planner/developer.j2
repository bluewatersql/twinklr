{#
GroupPlanner Developer Prompt - TECHNICAL CONSTRAINTS ONLY
See system.j2 for recipes and guidelines
#}
## Response Schema

Return a `SectionCoordinationPlan` matching this schema:

```json
{{ response_schema }}
```

## Enum Values (Use Exactly)

{% if taxonomy %}
- **LaneKind:** {{ taxonomy.LaneKind | join(', ') }}
- **CoordinationMode:** {{ taxonomy.CoordinationMode | join(', ') }}
- **IntensityLevel:** {{ taxonomy.IntensityLevel | join(', ') }}
- **EffectDuration:** {{ taxonomy.EffectDuration | join(', ') }}
- **StepUnit:** {{ taxonomy.StepUnit | join(', ') }}
- **TargetType:** {{ taxonomy.TargetType | join(', ') }}
- **SplitDimension:** {{ taxonomy.SplitDimension | join(', ') }}
- **DetailCapability:** {{ taxonomy.DetailCapability | join(', ') }}
{% else %}
- **LaneKind:** BASE, RHYTHM, ACCENT
- **CoordinationMode:** UNIFIED, COMPLEMENTARY, SEQUENCED, CALL_RESPONSE, RIPPLE
- **IntensityLevel:** WHISPER, SOFT, MED, STRONG, PEAK
- **EffectDuration:** HIT, BURST, PHRASE, EXTENDED, SECTION
- **StepUnit:** BEATS, BARS
- **TargetType:** group, zone, split
- **SplitDimension:** HALVES_LEFT, HALVES_RIGHT, THIRDS_LEFT, THIRDS_CENTER, THIRDS_RIGHT, ODD, EVEN
- **DetailCapability:** LOW, MEDIUM, HIGH
{% endif %}

**IMPORTANT:** Valid group target IDs are the exact `ChoreoGroup.id` values listed in the display graph (user prompt), NOT role names. Zone IDs are ChoreoTag values. Split IDs are SplitDimension values above.

## Targeting System

Use typed targets to specify what each coordination plan affects. Each target has a `type` and `id`:

| Type | id is | Example | Resolves To |
|------|-------|---------|-------------|
| `group` | ChoreoGroup.id | `{"type": "group", "id": "ARCHES"}` | That specific group |
| `zone` | ChoreoTag value | `{"type": "zone", "id": "HOUSE"}` | All groups tagged with HOUSE |
| `split` | SplitDimension value | `{"type": "split", "id": "HALVES_LEFT"}` | All groups with HALVES_LEFT membership |

**CRITICAL RULES:**
- Targets go in `coordination_plan.targets[]` (list of `{"type": ..., "id": ...}` objects).
- Placements also have a `target` field (single `{"type": ..., "id": ...}` object).
- The renderer resolves zone/split targets to concrete groups at composition time.
- **Different targets may overlap** in the same lane — this is valid and the renderer will blend/layer them.
- **The SAME target must NOT overlap itself** in the same lane (timing must be disjoint).

## Detail Capability (Template Suitability)

Match template complexity to group detail capability:
- **HIGH** (matrices, mega trees): Any template, including imagery and complex patterns
- **MEDIUM** (arches, wreaths, window frames): Patterns, gradients, moderate complexity
- **LOW** (candy canes, snowflakes, stars): Simple chases, solid colors, basic on/off

## Hard Constraints (Validation Failures)

| Constraint | Rule | Example Violation |
|------------|------|-------------------|
| Lane-Template Match | Each template type → its own lane ONLY: `gtpl_base_*` → BASE, `gtpl_rhythm_*` → RHYTHM, `gtpl_accent_*` → ACCENT | Using `gtpl_rhythm_*` in ACCENT lane, or `gtpl_accent_*` in RHYTHM lane |
| Valid targets | Target type/id must be valid group, zone, or split | `{"type": "zone", "id": "INVALID"}` |
| group_order ⊆ targets | Every `group_order` entry must be an ID from the same coordination plan's `targets`. No duplicates, no IDs from other lanes. | `targets: [ARCHES, CANDY_CANES]` but `group_order: ["MEGA_TREE", "ARCHES"]` |
| Window+config for SEQUENCED/CALL_RESPONSE | Must have window + config + non-empty group_order | SEQUENCED or CALL_RESPONSE mode missing config.group_order |
| Start within bounds | bar 1 to available_bars | bar 10 when section has 4 bars |
| No invented template_ids | every `template_id` ∈ template catalog | placement uses `template_id` not present in the template catalog |
| No same-target self-overlap | Same target (type+id) must be time-disjoint in a lane | Two zone:HOUSE placements overlap in RHYTHM lane |
| Same-target spacing | If either placement uses BURST, same target starts must be >= 1 bar apart; ACCENT same-target HITs should be >= 2 beats apart | BURST at bar 2 beat 1 and HIT at bar 2 beat 3 on same target |
| lane→target_roles mapping | BASE→[BACKGROUND], RHYTHM→[MID], ACCENT→[HERO] | ACCENT has target_roles [MID] |
| Cross-lane reuse policy | Default: a target appears in only one lane. Exception: group may appear in both RHYTHM+ACCENT only if allowlisted by `layer_intents.multilane_allowed_groups` | MEGA_TREE in RHYTHM+ACCENT without allowlist |
| Multi-lane override semantics | For allowlisted groups in both RHYTHM+ACCENT: overlap across lanes is allowed; ACCENT is higher-priority override during its intervals | Non-allowlisted group overlaps across lanes |
| No lane_plans planning_notes | `lane_plans[*]` must not include `planning_notes` | lane_plans.1.planning_notes present |

**Different targets CAN overlap.** For example, `zone:HOUSE` and `group:OUTLINE` can overlap in the same lane — the renderer will blend them.

**Do not invent `layer_intents` fields. Only apply allowlist rules if `layer_intents.multilane_allowed_groups` is present in the user prompt.**

**IMPORTANT**:
- **No extra fields:** Do not output any keys not present in the response schema.
  - Specifically: `lane_plans[*]` must NOT include `planning_notes` (only top-level `planning_notes` if schema supports it).


## SEQUENCED Mode Requirements

```json
{
  "coordination_mode": "SEQUENCED",
  "targets": [{"type": "group", "id": "ARCHES"}, {"type": "group", "id": "CANDY_CANES"}],
  "window": {
    "template_id": "gtpl_rhythm_chase_single",
    "start": {"bar": 1, "beat": 1},
    "end": {"bar": 4, "beat": 1},
    "intensity": "STRONG"
  },
  "config": {
    "group_order": ["ARCHES", "CANDY_CANES"],
    "step_unit": "BEATS",
    "step_duration": 2
  }
}
```

**Window sizing:** duration >= group_count × step_duration
**REQUIRED:** `config.group_order` must be non-empty for SEQUENCED and CALL_RESPONSE modes.

## UNIFIED Mode (Placements) — Zone Target Example

```json
{
  "coordination_mode": "UNIFIED",
  "targets": [{"type": "zone", "id": "HOUSE"}],
  "placements": [
    {
      "placement_id": "base_house_glow",
      "target": {"type": "zone", "id": "HOUSE"},
      "template_id": "gtpl_base_glow_warm",
      "start": {"bar": 1, "beat": 1},
      "duration": "SECTION",
      "intensity": "SOFT"
    }
  ]
}
```

The renderer expands `zone:HOUSE` to all HOUSE-tagged groups automatically.

## UNIFIED Mode — Group Target Example

```json
{
  "coordination_mode": "UNIFIED",
  "targets": [{"type": "group", "id": "MEGA_TREE"}],
  "placements": [
    {
      "placement_id": "accent_mega_tree_hit",
      "target": {"type": "group", "id": "MEGA_TREE"},
      "template_id": "gtpl_accent_hit_white",
      "start": {"bar": 2, "beat": 1},
      "duration": "HIT",
      "intensity": "PEAK"
    }
  ]
}
```

## CALL_RESPONSE Mode — Split Target Example

```json
{
  "coordination_mode": "CALL_RESPONSE",
  "targets": [{"type": "split", "id": "ODD"}, {"type": "split", "id": "EVEN"}],
  "window": {
    "template_id": "gtpl_rhythm_pulse_even",
    "start": {"bar": 1, "beat": 1},
    "end": {"bar": 4, "beat": 1},
    "intensity": "STRONG"
  },
  "config": {
    "group_order": ["ODD", "EVEN"],
    "step_unit": "BEATS",
    "step_duration": 2
  }
}
```

## Timing Format

```json
{"bar": 1, "beat": 1}  // Section-relative (bar 1 = section start)
```

- Bars: 1 to available_bars (see user prompt)
- Beats: 1 to 4 (assuming 4/4)
- Duration: HIT, BURST, PHRASE, EXTENDED, SECTION

{% if recipe_catalog and recipe_catalog.entries %}
## Recipe Catalog (FE-Promoted)

These recipes are multi-layer composite effects derived from feature engineering analysis. Prefer recipes with high model affinity for the target groups.

| recipe_id | name | type | layers | effect_types | model_affinities |
|-----------|------|------|--------|--------------|------------------|
{% for r in recipe_catalog.entries -%}
| {{ r.recipe_id }} | {{ r.name }} | {{ r.template_type }} | {{ r.layer_count }} | {{ r.effect_types | join(', ') }} | {% for a in r.model_affinities %}{{ a.model_type }}={{ a.score }}{% if not loop.last %}, {% endif %}{% endfor %} |
{% endfor %}
**Note:** Recipe IDs can be used as `template_id` in placements. The renderer will handle multi-layer composition automatically.
{% endif %}
